<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>The Scale of Everything - 3D Visualization</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; }
        
        #ui-layer {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            text-align: center;
            color: white;
            pointer-events: none;
            background: rgba(0,0,0,0.6);
            padding: 20px;
            border-radius: 15px;
            border: 1px solid #333;
            backdrop-filter: blur(5px);
        }

        input[type=range] {
            width: 100%;
            pointer-events: auto;
            margin-top: 15px;
        }

        h1 { margin: 0; font-size: 2.5rem; letter-spacing: 2px; text-transform: uppercase; text-shadow: 0 0 10px rgba(255,255,255,0.5); }
        p { font-size: 1.2rem; color: #aaa; margin: 5px 0; }
        .scale-readout { font-family: monospace; color: #00ffcc; font-size: 1.1rem; }

        #label-container {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        .obj-label {
            color: white;
            font-size: 2rem;
            font-weight: bold;
            text-shadow: 0 2px 4px black;
            opacity: 0;
            transition: opacity 0.5s;
            position: absolute;
            width: 100%;
            left: 0;
        }
        .obj-label.active { opacity: 1; }

    </style>
</head>
<body>

<div id="label-container"></div>

<div id="ui-layer">
    <h1 id="object-name">Sub-Atomic</h1>
    <p id="object-desc">Proton & Quarks</p>
    <div class="scale-readout">Scale: 10<sup id="exp-val">-15</sup> meters</div>
    <input type="range" id="zoomSlider" min="-16" max="27" step="0.01" value="-15">
</div>

<script type="module">
    import * as THREE from 'https://unpkg.com/three@0.158.0/build/three.module.js';

    // --- Configuration ---
    const SCENE_CONFIG = {
        starCount: 2000,
        bgColor: 0x050505
    };

    // --- Setup Scene ---
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(SCENE_CONFIG.bgColor, 0.02);
    scene.background = new THREE.Color(SCENE_CONFIG.bgColor);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.001, 1000);
    camera.position.z = 2; // Fixed camera, we scale the world

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    // --- Lighting ---
    const ambientLight = new THREE.AmbientLight(0x404040, 2);
    scene.add(ambientLight);
    const pointLight = new THREE.PointLight(0xffffff, 3, 100);
    pointLight.position.set(5, 5, 5);
    scene.add(pointLight);

    // --- Helper: Procedural Textures (To avoid external asset loading issues) ---
    function createGlowTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 64; canvas.height = 64;
        const ctx = canvas.getContext('2d');
        const grd = ctx.createRadialGradient(32,32,0,32,32,32);
        grd.addColorStop(0, 'rgba(255,255,255,1)');
        grd.addColorStop(0.4, 'rgba(255,255,255,0.4)');
        grd.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grd;
        ctx.fillRect(0,0,64,64);
        return new THREE.CanvasTexture(canvas);
    }

    function createNoiseTexture(color1, color2) {
        const canvas = document.createElement('canvas');
        canvas.width = 256; canvas.height = 256;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = color1;
        ctx.fillRect(0,0,256,256);
        for(let i=0; i<5000; i++) {
            ctx.fillStyle = color2;
            ctx.globalAlpha = Math.random() * 0.5;
            ctx.beginPath();
            ctx.arc(Math.random()*256, Math.random()*256, Math.random()*3, 0, Math.PI*2);
            ctx.fill();
        }
        return new THREE.CanvasTexture(canvas);
    }

    // --- Object Creators ---
    
    // 1. Proton (-15)
    function createProton() {
        const group = new THREE.Group();
        // Quarks
        const geometry = new THREE.SphereGeometry(0.2, 16, 16);
        const material = new THREE.MeshStandardMaterial({ 
            color: 0xff0055, emissive: 0x550022, roughness: 0.2 
        });
        
        const q1 = new THREE.Mesh(geometry, material);
        const q2 = new THREE.Mesh(geometry, material);
        const q3 = new THREE.Mesh(geometry, new THREE.MeshStandardMaterial({ color: 0x0055ff, emissive: 0x002255 }));
        
        q1.position.set(0.3, 0, 0);
        q2.position.set(-0.2, 0.3, 0);
        q3.position.set(-0.1, -0.3, 0.2);
        
        group.add(q1, q2, q3);
        
        // Energy cloud
        const cloudGeo = new THREE.SphereGeometry(0.8, 32, 32);
        const cloudMat = new THREE.MeshBasicMaterial({ 
            color: 0xffffff, transparent: true, opacity: 0.1, wireframe: true 
        });
        group.add(new THREE.Mesh(cloudGeo, cloudMat));
        
        // Animation hook
        group.userData.animate = (time) => {
            group.rotation.x = time * 2;
            group.rotation.y = time * 3;
            q1.position.y = Math.sin(time * 5) * 0.1;
        };
        return group;
    }

    // 2. Atom (-10)
    function createAtom() {
        const group = new THREE.Group();
        // Nucleus
        const nucGeo = new THREE.SphereGeometry(0.15, 16, 16);
        const nucMat = new THREE.MeshStandardMaterial({ color: 0xffaa00, emissive: 0xff4400 });
        group.add(new THREE.Mesh(nucGeo, nucMat));

        // Electron shells
        const orbitMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, side: THREE.DoubleSide });
        const ringGeo = new THREE.TorusGeometry(1, 0.02, 16, 100);
        
        const r1 = new THREE.Mesh(ringGeo, orbitMat);
        const r2 = new THREE.Mesh(ringGeo, orbitMat);
        const r3 = new THREE.Mesh(ringGeo, orbitMat);
        
        r1.rotation.x = Math.PI / 2;
        r2.rotation.y = Math.PI / 2;
        r3.rotation.x = Math.PI / 4;
        r3.rotation.y = Math.PI / 4;

        group.add(r1, r2, r3);

        // Electron particles
        const eGeo = new THREE.SphereGeometry(0.05, 8, 8);
        const eMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
        const e1 = new THREE.Mesh(eGeo, eMat);
        const e2 = new THREE.Mesh(eGeo, eMat);
        
        // Animation
        group.userData.animate = (time) => {
            group.rotation.z = time * 0.5;
            e1.position.set(Math.cos(time*4), Math.sin(time*4), 0);
            e2.position.set(0, Math.cos(time*5), Math.sin(time*5));
        };
        group.add(e1, e2);
        return group;
    }

    // 3. DNA (-8)
    function createDNA() {
        const group = new THREE.Group();
        const count = 20;
        const radius = 0.5;
        const height = 4;
        
        for(let i=0; i<count; i++) {
            const t = i / count;
            const angle = t * Math.PI * 4;
            const y = (t - 0.5) * height;

            const x1 = Math.cos(angle) * radius;
            const z1 = Math.sin(angle) * radius;
            const x2 = -x1;
            const z2 = -z1;

            const ballGeo = new THREE.SphereGeometry(0.1, 8, 8);
            const m1 = new THREE.Mesh(ballGeo, new THREE.MeshLambertMaterial({color: 0xff0000}));
            const m2 = new THREE.Mesh(ballGeo, new THREE.MeshLambertMaterial({color: 0x0000ff}));
            
            m1.position.set(x1, y, z1);
            m2.position.set(x2, y, z2);

            // Rung
            const barGeo = new THREE.CylinderGeometry(0.02, 0.02, radius*2, 4);
            const bar = new THREE.Mesh(barGeo, new THREE.MeshBasicMaterial({color: 0xcccccc}));
            bar.position.set(0, y, 0);
            bar.rotation.y = -angle;
            bar.rotation.z = Math.PI / 2;

            group.add(m1, m2, bar);
        }
        
        group.rotation.z = Math.PI / 4;
        group.userData.animate = (time) => {
            group.rotation.y = time * 0.2;
        }
        return group;
    }

    // 4. Beach Ball (-1)
    function createBeachBall() {
        const geometry = new THREE.SphereGeometry(1, 32, 32);
        const canvas = document.createElement('canvas');
        canvas.width = 128; canvas.height = 128;
        const ctx = canvas.getContext('2d');
        const colors = ['white', 'red', 'white', 'blue', 'white', 'yellow'];
        colors.forEach((c, i) => {
            ctx.fillStyle = c;
            ctx.fillRect(i * (128/6), 0, 128/6, 128);
        });
        const texture = new THREE.CanvasTexture(canvas);
        const material = new THREE.MeshStandardMaterial({ map: texture, roughness: 0.1, metalness: 0.1 });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.userData.animate = (time) => {
            mesh.rotation.y = time;
            mesh.rotation.x = Math.sin(time) * 0.2;
        }
        return mesh;
    }

    // 5. Earth (7)
    function createEarth() {
        const geometry = new THREE.SphereGeometry(1, 64, 64);
        const tex = createNoiseTexture('#001133', '#0044ff'); // Ocean
        // Simple continents via noise in a real app, here simple blue sphere with atmosphere
        const material = new THREE.MeshPhongMaterial({ 
            color: 0x2233ff, emissive: 0x001133, specular: 0x111111, shininess: 10,
            map: tex 
        });
        const earth = new THREE.Mesh(geometry, material);

        // Clouds
        const cGeo = new THREE.SphereGeometry(1.02, 64, 64);
        const cMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.3 });
        const clouds = new THREE.Mesh(cGeo, cMat);
        earth.add(clouds);

        earth.userData.animate = (time) => {
            earth.rotation.y = time * 0.1;
            clouds.rotation.y = time * 0.12;
        }
        return earth;
    }

    // 6. Sun (9)
    function createSun() {
        const geometry = new THREE.SphereGeometry(1, 64, 64);
        const material = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
        const sun = new THREE.Mesh(geometry, material);
        
        // Corona glow
        const glowGeo = new THREE.SphereGeometry(1.2, 32, 32);
        const glowMat = new THREE.MeshBasicMaterial({ color: 0xff8800, transparent: true, opacity: 0.3, side: THREE.BackSide });
        const glow = new THREE.Mesh(glowGeo, glowMat);
        sun.add(glow);

        sun.userData.animate = (time) => {
            // Sun pulsing
            const s = 1 + Math.sin(time * 2) * 0.02;
            sun.scale.set(s,s,s);
        }
        return sun;
    }

    // 7. Galaxy (21)
    function createGalaxy() {
        const particles = new THREE.BufferGeometry();
        const count = 5000;
        const positions = new Float32Array(count * 3);
        const colors = new Float32Array(count * 3);
        const colorObj = new THREE.Color();

        for(let i=0; i<count; i++) {
            const branchAngle = (i % 3) * ((2 * Math.PI) / 3);
            const radius = Math.random() * 2; // Galaxy radius
            const spinAngle = radius * 5;
            
            const randomX = Math.random() * 0.3 - 0.15;
            const randomY = Math.random() * 0.3 - 0.15;
            const randomZ = Math.random() * 0.3 - 0.15;

            const x = Math.cos(branchAngle + spinAngle) * radius + randomX;
            const z = Math.sin(branchAngle + spinAngle) * radius + randomZ;
            const y = (Math.random() - 0.5) * 0.2 * (2 - radius); // Thicker center

            positions[i*3] = x;
            positions[i*3+1] = y;
            positions[i*3+2] = z;

            // Color gradient: Center (yellow/white) -> Edge (Purple/Blue)
            const dist = Math.sqrt(x*x + z*z);
            if(dist < 0.5) colorObj.setHSL(0.1, 1, 0.8);
            else colorObj.setHSL(0.6 + Math.random()*0.2, 0.8, 0.5);
            
            colors[i*3] = colorObj.r;
            colors[i*3+1] = colorObj.g;
            colors[i*3+2] = colorObj.b;
        }
        particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const mat = new THREE.PointsMaterial({ 
            size: 0.02, vertexColors: true, blending: THREE.AdditiveBlending, depthWrite: false 
        });
        const galaxy = new THREE.Points(particles, mat);
        
        galaxy.rotation.x = Math.PI / 3;

        galaxy.userData.animate = (time) => {
            galaxy.rotation.y = time * -0.05;
        }
        return galaxy;
    }

    // 8. Universe (26)
    function createUniverse() {
        const geo = new THREE.BufferGeometry();
        const count = 1000;
        const pos = [];
        for(let i=0; i<count; i++) {
            const r = 2 + Math.random() * 2;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            pos.push(
                r * Math.sin(phi) * Math.cos(theta),
                r * Math.sin(phi) * Math.sin(theta),
                r * Math.cos(phi)
            );
        }
        geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
        const mat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.03, opacity: 0.6, transparent: true });
        return new THREE.Points(geo, mat);
    }

    // --- Background Stars (Static background) ---
    function createStarfield() {
        const geo = new THREE.BufferGeometry();
        const pos = [];
        for(let i=0; i<SCENE_CONFIG.starCount; i++) {
            pos.push((Math.random()-0.5)*200, (Math.random()-0.5)*200, -50 + (Math.random()-0.5)*50);
        }
        geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
        const mat = new THREE.PointsMaterial({color: 0x555555, size: 0.1});
        scene.add(new THREE.Points(geo, mat));
    }
    createStarfield();

    // --- Data Structure ---
    const objects = [
        { name: "Proton", exp: -15, desc: "Building block of nuclei", mesh: createProton() },
        { name: "Hydrogen Atom", exp: -10, desc: "Simplest element", mesh: createAtom() },
        { name: "DNA Strand", exp: -8, desc: "Blueprint of life", mesh: createDNA() },
        { name: "Virus", exp: -7, desc: "Biological nanobot", mesh: (() => { 
            const g = new THREE.IcosahedronGeometry(1, 0); 
            return new THREE.Mesh(g, new THREE.MeshStandardMaterial({color: 0x00ff00, wireframe: true})); 
        })() },
        { name: "Sand Grain", exp: -3, desc: "Tiny silica crystal", mesh: (() => {
            return new THREE.Mesh(new THREE.DodecahedronGeometry(1), new THREE.MeshStandardMaterial({color: 0xccaa88, roughness: 1}));
        })() },
        { name: "Beach Ball", exp: -1, desc: "Human scale", mesh: createBeachBall() },
        { name: "Mount Everest", exp: 4, desc: "Highest peak", mesh: (() => {
            const g = new THREE.ConeGeometry(1, 1.5, 4);
            return new THREE.Mesh(g, new THREE.MeshStandardMaterial({color: 0xffffff}));
        })() },
        { name: "Earth", exp: 7, desc: "Our home", mesh: createEarth() },
        { name: "Sun", exp: 9, desc: "Our star", mesh: createSun() },
        { name: "Solar System", exp: 12, desc: "Planetary neighborhood", mesh: (() => {
            const g = new THREE.RingGeometry(1.5, 2, 32);
            g.rotateX(-Math.PI/2);
            return new THREE.Mesh(g, new THREE.MeshBasicMaterial({color: 0x444444, side: THREE.DoubleSide, transparent: true, opacity: 0.5}));
        })() },
        { name: "Milky Way", exp: 21, desc: "Our galaxy", mesh: createGalaxy() },
        { name: "Observable Universe", exp: 26, desc: "Cosmic Web", mesh: createUniverse() }
    ];

    // Add all to scene but hide initially
    objects.forEach(obj => {
        scene.add(obj.mesh);
        obj.mesh.visible = false;
    });

    // --- UI Logic ---
    const slider = document.getElementById('zoomSlider');
    const nameEl = document.getElementById('object-name');
    const descEl = document.getElementById('object-desc');
    const expEl = document.getElementById('exp-val');

    // --- Main Loop ---
    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);
        
        const time = clock.getElapsedTime();
        const currentExp = parseFloat(slider.value);
        
        // Update UI Text
        expEl.innerText = currentExp.toFixed(1);
        
        // Find closest object for label
        let closestObj = objects[0];
        let minDiff = 1000;
        
        objects.forEach(obj => {
            // Animate internal mesh if function exists
            if(obj.mesh.userData.animate) obj.mesh.userData.animate(time);

            // Calculate Scale
            // Visual Scale = BaseSize * 10 ^ (ObjectExponent - CameraExponent)
            // If Object is at 10^7 and Cam is at 10^7, scale is 1.
            const scalePower = obj.exp - currentExp;
            const scale = Math.pow(10, scalePower);

            obj.mesh.scale.set(scale, scale, scale);

            // Visibility Logic (Fade in/out based on scale)
            // Visible range: 0.001 to 100
            if (scale > 0.001 && scale < 50) {
                obj.mesh.visible = true;
                
                // Fade opacity if supported (mostly for materials that are transparent)
                // This is a simplified fade logic
            } else {
                obj.mesh.visible = false;
            }

            // UI Update Logic
            if(Math.abs(scalePower) < minDiff) {
                minDiff = Math.abs(scalePower);
                closestObj = obj;
            }
        });

        if(minDiff < 1.5) {
            nameEl.innerText = closestObj.name;
            descEl.innerText = closestObj.desc;
            nameEl.style.opacity = 1 - (minDiff/1.5);
        } else {
            nameEl.style.opacity = 0.2;
        }

        renderer.render(scene, camera);
    }

    // --- Interaction ---
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();

</script>
</body>
</html>
